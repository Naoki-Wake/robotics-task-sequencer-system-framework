# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
# --------------------------------------------------------------------------------------------

from __future__ import annotations
import enum
import typing
import numpy as np

import tasqsym.core.common.constants as tss_constants


class Status:
    def __init__(self, status: tss_constants.StatusFlags, reason: tss_constants.StatusReason=tss_constants.StatusReason.NONE, message: str=""):
        """
        status:  success or failure pattern used at sequence control level
        reason:  a more detailed category within the success or failure pattern used at skill control level or for analysis
        message: messages if any
        """
        self.status = status
        self.reason = reason
        self.message = message

class Point(typing.NamedTuple):
    x: float
    y: float
    z: float

class Quaternion(typing.NamedTuple):  # w + xi + yj + zk
    x: float
    y: float
    z: float
    w: float

class TransformPair(typing.NamedTuple):
    base: Quaternion | list
    transform: Quaternion | list

class Pose(typing.NamedTuple):
    position: Point | list | np.ndarray = Point(0., 0., 0.)
    orientation: Quaternion | list = Quaternion(0., 0., 0., 1.)

class Data:
    """Data can be any structure generated from a dictionary."""
    def __init__(self, dat: dict):
        for key, value in dat.items():
            if key[0] == "@": setattr(self, key[1:], value)
            else: setattr(self, key, value)

class RobotAction:
    """A base class to define actions returned by the skills."""
    solveby_type: tss_constants.SolveByType
    configs: dict
    def __init__(self, solveby_type: tss_constants.SolveByType, configs: dict):
        """
        solveby_type: action by the controller is generated by this type
        configs:      any configrations (not recommended for usage)
        """
        self.solveby_type = solveby_type
        self.configs = configs

class CombinedRobotAction:
    """Class to hold the actions of all robots in the combined robot tree."""
    task: str
    actions: dict[str, list[RobotAction]]
    def __init__(self, task: str, actions: dict[str, list[RobotAction]]):
        """
        task:    refers to the current skill being executed (the model robot may use this information to trigger different solvers)
        actions: robot ID and its list of actions (an action is any derived class of the RobotAction class)
        """
        self.task = task
        self.actions = actions

class RobotState:
    """A base class to store the robot state returned by the controller or to store a desired robot state."""
    def __init__(self, base_state: Pose, status: Status=Status(tss_constants.StatusFlags.SUCCESS), timesec: float=None):
        """
        base_state: the robot's root link pose in the world coordinate
        status:     whether errors occured when obtaining/generating the state
        timesec:    the desired execution time if a desired state (controller to calculate the optimal time if None)
        """
        self.base_state = base_state
        self.status = status
        self.timesec = timesec

class JointStates(typing.NamedTuple):
    positions:  list[float]
    velocities: typing.Optional[list[float]]=None
    efforts:    typing.Optional[list[float]]=None
    # since just a tuple, can add other fields if needed for custom skills/adapters

class ManipulatorState(RobotState):
    """Robots of roles Manipulator and MobileManipulator should use this class instead of the RobotState class."""
    def __init__(self, joint_names: list[str], joint_states: JointStates, base_state: Pose,
                 status: Status=Status(tss_constants.StatusFlags.SUCCESS), timesec: float=None):
        """
        joint_names:  a list of the robot's joints
        joint_states: the state of each joint corresponding to the joint_names
        base_state:   the robot's root link pose in the world coordinate
        status:       whether errors occured when obtaining/generating the state
        timesec:      the desired execution time if a desired state (controller to calculate the optimal time if None)
        """
        super().__init__(base_state, status, timesec)
        self.joint_names = joint_names
        self.joint_states = joint_states

class EndEffectorState(RobotState):
    """Robots of roles EndEffector should use this class instead of the RobotState class."""
    class ContactAnnotations(enum.Enum):
        CONTACT_CENTER = 0  # should be the default annotation for most skills
        PALM = 1
        FINGERTIP_0 = 2
        FINGERTIP_1 = 3
        FINGERTIP_2 = 4
        FINGERTIP_3 = 5
        FINGERTIP_4 = 6
    def __init__(self, joint_names: list[str], joint_states: JointStates, base_link_name: str="", base_state: Pose=Pose(), 
                 contact_link_names: list[str]=[], contact_annotations: list[EndEffectorState.ContactAnnotations]=[], contact_link_states: list[Pose]=[],
                 status: Status=Status(tss_constants.StatusFlags.SUCCESS), timesec: float=None):
        """
        joint_names:         a list of the robot's joints
        joint_states:        the state of each joint corresponding to the joint_names
        base_link_name:      the parent link where the end-effector is attached to the manipulator
        base_state:          the position and orientation of the base link in the world coordinate
        contact_link_names:  any contact links on the end-effector (e.g., palm, fingertip)
        contact_annotations: i-th element indicates whether the i-th contact link in contact_link_names represents a contact_center/palm/fingertip
        contact_link_states: i-th element is the pose of the i-th contact link in contact_link_names
        status:              whether errors occured when obtaining/generating the state
        timesec:             the desired execution time if a desired state (controller to calculate the optimal time if None)
        """
        super().__init__(base_state, status, timesec)
        self.joint_names = joint_names
        self.joint_states = joint_states
        self.base_link_name = base_link_name
        if len(contact_link_names) != len(contact_annotations): assert False
        if len(contact_link_states) != len(contact_annotations): assert False
        self.contact_link_names: dict[EndEffectorState.ContactAnnotations, str] = {}
        for i, ca in enumerate(contact_annotations):
            if ca in self.contact_link_names: assert False  # only one link per one annotation allowed
            self.contact_link_names[ca] = contact_link_names[i]
        self.contact_link_states: dict[EndEffectorState.ContactAnnotations, Pose] = {}
        for i, ca in enumerate(contact_annotations):
            self.contact_link_states[ca] = contact_link_states[i]

class CombinedRobotState:
    """Class to hold the states of all robots in the combined robot tree."""
    robot_states: dict[str, RobotState]
    status:       Status
    def __init__(self, robot_states: dict[str, RobotState], status: Status=Status(tss_constants.StatusFlags.UNKNOWN)):
        """
        robot_states: robot ID and its state
        status:       status should be set to success if none of the robots contain any errors
        """
        self.robot_states = robot_states
        self.status = status
